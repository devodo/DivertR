---
layout: default
title: Dependency Injection
nav_order: 2
parent: Documentation
---

# Dependency Injection

{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

DivertR is designed to be embedded easily and transparently into the dependency injection (DI) container to facilitate testing an integrated, wired-up system.
It does this by decorating existing DI service registrations with [Redirects](../redirects/) that replace the originals.
These Redirects create proxies that wrap the instances resolved from the originals as their default targets or *roots*.

By default Redirect proxies transparently forward calls to their roots and therefore, in this initial state, the behaviour of the DI system is unchanged.
Then specific parts of the system can be modified as required by dynamically updating and resetting proxies between tests without requiring restart.

## .NET ServiceCollection

Out the box DivertR has support for the .NET `Microsoft.Extensions.DependencyInjection.IServiceCollection`. The examples that follow use this `ServiceCollection` and its registered dependencies:

```csharp
IServiceCollection services = new ServiceCollection();

services.AddTransient<IFoo, Foo>();
services.AddSingleton<IBarFactory, BarFactory>();
services.AddSingleton<IEtc, Etc>();
```

# Redirect Registration

First instantiate an instance of the `Diverter` class and *register* one or more DI service types of interest that you would like be wrapped as Redirect proxies:

```csharp
var diverter = new Diverter()
    .Register<IFoo>()
    .Register<IBarFactory>();
```

Then call `Divert`, a provided `IServiceCollection` extension method, to install the registered types as `Redirect` decorators:

```csharp
services.Divert(diverter);
```

The `IServiceCollection` can now be used as usual to build the service provider and resolve dependency instances:

```csharp
IServiceProvider provider = services.BuildServiceProvider();

var foo = provider.GetService<IFoo>();
Console.WriteLine(foo.Name); // "Foo"

// The behaviour of the resolved foo is the same as its root e.g.:
IFoo demo = new Foo();
Console.WriteLine(demo.Name); // "Foo";
```

# Redirect Configuration

The resolved `IFoo` instance above is a Redirect proxy generated by the underlying `IRedirect<IFoo>` decorator that uses the original DI registration to initialise the proxy root.
In its initial state the `IFoo` proxy forwards all calls directly to its root. However, this behaviour can be modified by obtaining the underlying `Redirect`
from the `Diverter` instance and adding a *Via*:

```csharp
// Obtain the underlying Redirect from the diverter instance
IRedirect<IFoo> fooRedirect = diverter.Redirect<IFoo>(); 

fooRedirect
    .To(x => x.Name)
    .Via(call => $"{call.Root.Name} diverted");

var foo = provider.GetService<IFoo>();
Console.WriteLine(foo.Name); // "Foo diverted"
```

Any Vias added to the `Redirect` are applied to all its existing proxies and any resolved afterwards:

```csharp
var foo2 = provider.GetService<IFoo>();
foo2.Name = "Foo2";
Console.WriteLine(foo2.Name); // "Foo2 diverted"
```

# Reset

All Redirects registered in the `Diverter` instance and resolved proxies can be *reset* to their initial state with a single call:

```csharp
diverter.ResetAll();
  
Console.WriteLine(foo.Name);  // "Foo"
Console.WriteLine(foo2.Name);  // "Foo2"
```

# Redirect Set


# Via Redirect

Sometimes a test needs to manipulate instances that are not directly created by the DI container.
E.g. if we assume the `IBarFactory` service registration given above is a factory that creates `IBar` instances.
These instances can be wrapped and managed as Redirect proxies by calling `ViaRedirect` as follows:

```csharp

// Wrap created IBar instances as Redirect proxies and get a reference their Redirect
IRedirect<IBar> barRedirect = diverter
    .Redirect<IBarFactory>()
    .To(x => x.Create(Is<string>.Any))
    .ViaRedirect();

var barFactory = provider.GetService<IBarFactory>();
IBar bar = barFactory.Create("MrBar"); // The Create call now returns IBar proxies
Console.WriteLine(bar.Name); // "MrBar"

// Add a Via to alter behaviour
barRedirect
   .To(x => x.Name)
   .Via(call => call.Root.Name + " diverted");

Console.WriteLine(bar.Name); // "MrBar diverted"

// ResetAll also resets ViaRedirects
diverter.ResetAll();
Console.WriteLine(bar.Name); // "MrBar"
```

`ViaRedirect` intercepts the method return values and wraps them as proxies created from a Redirect.
It returns this Redirect that can then be used to control the behaviour of the proxy wrappers.

# Proxy Lifetime

To maintain the original system behaviour when DivertR replaces existing DI registrations with Redirect decorators the lifetime is preserved.

When instances are resolved from a Redirect decoratored registration a new proxy is created each time but all from the same Redirect instance.
Therefore if the Redirect configuration is changed, e.g. by adding a Via, it is applied across all of the Redirect's proxy instances. 
This is important for managing proxies with lifetimes like transient where multiple instances could be resolved.

# Dispose

DivertR takes care to ensure DI resolved instances such as Redirect proxies and the root instances they wrap are correctly disposed. 

If a root instance implements the `IDisposable` interface then the DI container manages its disposal, as usual, according to its registration lifetime.

If the Redirect target type inherits `IDisposable` then **only** the proxy instances are disposed by the DI container and not the root.
In this case the responsibilty is left to the proxy for forwarding the dispose call to its root (and it does this by default).

The above dispose pattern also applies to `IAsyncDisposable` types.
