# Dependency Injection

DivertR is designed to be embedded easily and transparently into the dependency injection (DI) container to facilitate testing an integrated, wired-up system.
It does this by decorating existing DI service registrations with [Redirects](./Redirect.md) that replace the originals.
These Redirects create proxies that wrap the instances resolved from the originals as their default targets or *roots*.

By default Redirect proxies transparently forward calls to their roots and therefore, in this initial state, the behaviour of the DI system is unchanged.
Then specific parts of the system can be modified as required by dynamically updating and resetting proxies between tests without requiring restart.

# .NET ServiceCollection

Out the box DivertR has support for the .NET `Microsoft.Extensions.DependencyInjection.IServiceCollection`. The examples below use the following `ServiceCollection` and its registrations:

```csharp
IServiceCollection services = new ServiceCollection();

services.AddTransient<IFoo, Foo>();
services.AddSingleton<IBarFactory, BarFactory>();
services.AddSingleton<IEtc, Etc>();
```

# Redirect Registration

First instantiate an instance of the `Diverter` class and *register* one or more DI service types of interest that you would like be wrapped as Redirect proxies:

```csharp
var diverter = new Diverter()
    .Register<IFoo>()
    .Register<IBarFactory>();
```

Then call `Divert`, a provided `IServiceCollection` extension method, to install the registered types as `Redirect` decorators:

```csharp
services.Divert(diverter);
```

The `IServiceCollection` can now be used as usual to build the service provider and resolve dependency instances:

```csharp
IServiceProvider provider = services.BuildServiceProvider();

var foo = provider.GetService<IFoo>();
Console.WriteLine(foo.Name); // "Foo"

// The behaviour of the resolved foo is the same as its root e.g.:
IFoo demo = new Foo();
Console.WriteLine(demo.Name); // "Foo";
```

# Redirect Configuration

The resolved `IFoo` instance above is a Redirect proxy generated by the underlying `IRedirect<IFoo>` decorator that uses the original DI registration to initialise the proxy root. 
In its initial state the `IFoo` proxy forwards all calls directly to its root. However, this behaviour can be modified by obtaining the underlying `Redirect`
from the `Diverter` instance and adding a *Via*:

```csharp
// Obtain the underlying Redirect from the diverter instance
IRedirect<IFoo> fooRedirect = diverter.Redirect<IFoo>(); 

fooRedirect
    .To(x => x.Name)
    .Via(call => $"{call.Root.Name} diverted");

var foo = provider.GetService<IFoo>();
Console.WriteLine(foo.Name); // "Foo diverted"
```

Any Vias added to the `Redirect` are applied to all its existing proxies and any resolved afterwards:

```csharp
var foo2 = provider.GetService<IFoo>();
foo2.Name = "Foo2";
Console.WriteLine(foo2.Name); // "Foo2 diverted"
```

# Reset

All Redirects registered in the `Diverter` instance and resolved proxies can be *reset* to their initial state with a single call:

```csharp
diverter.ResetAll();
  
Console.WriteLine(foo.Name);  // "Foo"
Console.WriteLine(foo2.Name);  // "Foo2"
```

# ViaRedirect

Sometimes a test needs to manipulate instances that are not directly created by the DI container.
E.g. if we assume the `IBarFactory` service registration given above is a factory that creates `IBar` instances.
These instances can be wrapped and managed as Redirect proxies by calling `ViaRedirect` as follows:

```csharp

// Wrap created IBar instances as Redirect proxies and get a reference their Redirect
IRedirect<IBar> barRedirect = diverter
    .Redirect<IBarFactory>()
    .To(x => x.Create(Is<string>.Any))
    .ViaRedirect();

var barFactory = provider.GetService<IBarFactory>();
IBar bar = barFactory.Create("MrBar"); // The Create call now returns IBar proxies
Console.WriteLine(bar.Name); // "MrBar"

// Add a Via to alter behaviour
barRedirect
   .To(x => x.Name)
   .Via(call => call.Root.Name + " diverted");

Console.WriteLine(bar.Name); // "MrBar diverted"

// ResetAll also resets ViaRedirects
diverter.ResetAll();
Console.WriteLine(bar.Name); // "MrBar"
```

# Proxy Lifetime

DivertR aims to leave the original system behaviour unchanged and therefore 
when existing DI registrations are replaced by Redirect decorators the lifetime of the registration is preserved.

For multiple instance registrations such as transients, a separate proxy instance is created for each but all from the same Redirect instance.
In other words all proxies resolved from a Redirect decorated registration are managed from this single Redirect.

# Dispose

If a DI created root instance implements the `IDisposable` interface then the DI container manages its disposal, as usual, according to its registration lifetime.

If a DI Redirect proxy is an `IDisposable` then **only** the proxy instance is disposed by the DI container and not the root.
In this case the responsibilty is left to the proxy for forwarding the dispose call to its root (and it does this by default).

The above also applies to `IAsyncDisposable`.
