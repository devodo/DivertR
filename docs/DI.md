# Dependency Injection

DivertR is designed to be embedded easily and transparently into the dependency injection (DI) container to facilitate testing an integrated, wired-up system.
It does this by decorating existing DI service registrations with [Vias](./Via.md) that replace the originals.
These Vias create proxies that wrap the instances resolved from the originals as their default targets or *roots*.

By default Via proxies transparently forward calls to their roots and therefore, in this initial state, the behaviour of the DI system is unchanged.
Then specific parts of the system can be modified as required by dynamically updating and resetting proxies between tests without requiring restart.

# .NET ServiceCollection

Out the box DivertR has support for the .NET `Microsoft.Extensions.DependencyInjection.IServiceCollection`. The examples below use the following `ServiceCollection` and its registrations:

```csharp
IServiceCollection services = new ServiceCollection();

services.AddTransient<IFoo, Foo>();
services.AddSingleton<IBarFactory, BarFactory>();
services.AddSingleton<IEtc, Etc>();
```

# Via Registration

First instantiate an instance of the `Diverter` class and *register* one or more DI service types of interest that you would like be wrapped as Via proxies:

```csharp
var diverter = new Diverter()
    .Register<IFoo>()
    .Register<IBarFactory>();
```

Then call `Divert`, a provided `IServiceCollection` extension method, to install the registered types as `Via` decorators:

```csharp
services.Divert(diverter);
```

The `IServiceCollection` can now be used as usual to build the service provider and resolve dependency instances:

```csharp
IServiceProvider provider = services.BuildServiceProvider();

var foo = provider.GetService<IFoo>();
Console.WriteLine(foo.Name); // "Foo"

// The behaviour of the resolved foo is the same as its root e.g.:
IFoo demo = new Foo();
Console.WriteLine(demo.Name); // "Foo";
```

# Via Configuration

The resolved `IFoo` instance above is a Via proxy generated by the underlying `IVia<IFoo>` decorator that uses the original DI registration to initialise the proxy root. 
In its initial state the `IFoo` proxy forwards all calls directly to its root. However, this behaviour can be modified by obtaining the underlying `Via`
from the `Diverter` instance and adding a *redirect*:

```csharp
// Obtain the underlying Via from the diverter instance
IVia<IFoo> fooVia = diverter.Via<IFoo>(); 

fooVia
    .To(x => x.Name)
    .Redirect(call => $"{call.Root.Name} diverted");

var foo = provider.GetService<IFoo>();
Console.WriteLine(foo.Name); // "Foo diverted"
```

Any redirects added to the `Via` are applied to all its existing proxies and any resolved afterwards:

```csharp
var foo2 = provider.GetService<IFoo>();
foo2.Name = "Foo2";
Console.WriteLine(foo2.Name); // "Foo2 diverted"
```

# Reset

All Vias registered in the `Diverter` instance and resolved proxies can be *reset* to their initial state with a single call:

```csharp
diverter.ResetAll();
  
Console.WriteLine(foo.Name);  // "Foo"
Console.WriteLine(foo2.Name);  // "Foo2"
```

# RedirectVia

Sometimes a test needs to manipulate instances that are not directly created by the DI container.
E.g. if we assume the `IBarFactory` service registration given above is a factory that creates `IBar` instances.
These instances can be wrapped and managed as Via proxies by calling `RedirectVia` as follows:

```csharp

// Wrap created IBar instances as Via proxies and get a reference their Via
IVia<IBar> barVia = diverter
    .Via<IBarFactory>()
    .To(x => x.Create(Is<string>.Any))
    .RedirectVia();

var barFactory = provider.GetService<IBarFactory>();
IBar bar = barFactory.Create("MrBar"); // The Create call now returns IBar proxies
Console.WriteLine(bar.Name); // "MrBar"

// Add a redirect to alter behaviour
barVia
   .To(x => x.Name)
   .Redirect(call => call.Root.Name + " diverted");

Console.WriteLine(bar.Name); // "MrBar diverted"

// ResetAll also resets RedirectVias
diverter.ResetAll();
Console.WriteLine(bar.Name); // "MrBar"
```

# Proxy Lifetime

DivertR aims to leave the original system behaviour unchanged and therefore 
when existing DI registrations are replaced by Via decorators the lifetime of the registration is preserved.

For multiple instance registrations such as transients, a separate proxy instance is created for each but all from the same Via instance.
In other words all proxies resolved from a Via decorated registration are managed from this single Via.

# Dispose

If a DI created root instance implements the `IDisposable` interface then the DI container manages its disposal, as usual, according to its registration lifetime.

If a DI Via proxy is an `IDisposable` then **only** the proxy instance is disposed by the DI container and not the root.
In this case the responsibilty is left to the proxy for forwarding the dispose call to its root (and it does this by default).

The above also applies to `IAsyncDisposable`.
